<html>

<head>
</head>

<body>
<canvas width="500" height="500" id="canvas"></canvas>
</body>
<script type="text/javascript" src="http://lufylegend.com/js/Box2dWeb-2.1.a.3.min.js"></script> 
<script src="/socket.io/socket.io.js"></script>
<script>
	var p_id;
	var num_players;
	//var socket = io.connect('http://compute.cse.tamu.edu:24130');
	var socket = io.connect('http://192.168.1.100:24130');
	var start_positions = new Array();
	start_positions[0] = {x: 10, y: 10};
	start_positions[1] = {x: 50, y: 10};
	start_positions[2] = {x: 10, y: 20};
	start_positions[3] = {x: 20, y: 20};
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	var width = canvas.width;
	var height = canvas.height;
	var    b2Vec2 = Box2D.Common.Math.b2Vec2
	,	   b2Cross = Box2D.Common.Math.b2Cross
	,      b2BodyDef = Box2D.Dynamics.b2BodyDef
	,      b2Body = Box2D.Dynamics.b2Body
	,      b2FixtureDef = Box2D.Dynamics.b2FixtureDef
	,      b2World = Box2D.Dynamics.b2World
	,      b2BoxDef = Box2D.Dynamics.b2BoxDef
	,      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
	,      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
	,	   b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape
	,      b2RevoluteJointDef=Box2D.Dynamics.Joints.b2RevoluteJointDef
	,      b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
	,      b2DebugDraw = Box2D.Dynamics.b2DebugDraw
	,      b2Fixture = Box2D.Dynamics.b2Fixture
	,      b2AABB = Box2D.Collision.b2AABB;
	var bodyDef = new b2BodyDef;
	bodyDef.type = b2Body.b2_dynamicBody;
	bodyDef.position.Set(4, 8);
	bodyDef.userData = 'BOX';
	var myFixture = new b2FixtureDef;
	myFixture.shape = new b2CircleShape(3);
	myFixture.density = 1;
	myFixture.friction = 0.5;
	myFixture.restitution = 0.5;
	
	var world = new b2World(new b2Vec2(0, 0), false);	

	var Wall_one = new b2FixtureDef;
	Wall_one.density = .5;
	Wall_one.friction = 0.4;
	Wall_one.restitution = 0.2;
	var bodyDef2 = new b2BodyDef;
	bodyDef2.type = b2Body.b2_staticBody;
	/*
 	Wall_one.shape = new b2PolygonShape;
	Wall_one.shape.SetAsBox(width/2,4);
	bodyDef.position.Set(width/2, 0);
	world.CreateBody(bodyDef).CreateFixture(Wall_one);
	bodyDef.position.Set(width/2, (height/10));
	world.CreateBody(bodyDef).CreateFixture(Wall_one);
	Wall_one.shape.SetAsBox(2,height/2);
	bodyDef.position.Set(0, height/2);
	world.CreateBody(bodyDef).CreateFixture(Wall_one);
	bodyDef.position.Set(width/10, height/2);
	world.CreateBody(bodyDef).CreateFixture(Wall_one); 
	*/
	var started = false;
	var bodies = new Array();
	var posX, posY, ang;
	socket.on('player connected', function(data) {
		console.log("player connected");
		p_id = data.playerID;
			
		
		
					
		num_players = data.num_players;	
		
		bodies[num_players-1] = world.CreateBody(bodyDef); 
		bodies[num_players-1].SetPositionAndAngle(new b2Vec2(start_positions[p_id].x, start_positions[p_id].y),0);
		bodies[num_players-1].SetLinearVelocity(new b2Vec2(0, 0));
		bodies[num_players-1].SetFixedRotation(false);
		bodies[num_players-1].SetAngularVelocity(0);
		bodies[num_players-1].CreateFixture(myFixture);
		bodies[num_players-1]["playerID"] = p_id;
		console.log("num_players: " + num_players);		
		console.log("player ID: " + bodies[num_players-1]["playerID"]);		
		
		for(i = num_players-2; i >= 0; i--) {
			bodies[i] = world.CreateBody(bodyDef); 
			bodies[i].SetPositionAndAngle(new b2Vec2(start_positions[i].x, start_positions[i].y),0);
			bodies[i].SetLinearVelocity(new b2Vec2(0, 0));
			bodies[i].SetFixedRotation(false);
			bodies[i].SetAngularVelocity(0);
			bodies[i].CreateFixture(myFixture);
			bodies[i]["playerID"] = i;
			console.log("i: " + i);
			console.log("num_players: " + num_players);		
			console.log("player ID: " + bodies[i]["playerID"]);
		
		}
		
		started = true;
		socket.emit('wh', {width : canvas.width, height : canvas.height });		
		
	});
	
	socket.on('player joined', function(data) {
		console.log("another player joined");
		if(data.num_players > num_players) {
			num_players = data.num_players;
			bodies[num_players-1] = world.CreateBody(bodyDef); 
			bodies[num_players-1].SetPositionAndAngle(
				new b2Vec2(start_positions[num_players-1].x, start_positions[num_players-1].y),0);
			bodies[num_players-1].SetLinearVelocity(new b2Vec2(0, 0));
			bodies[num_players-1].SetFixedRotation(false);
			bodies[num_players-1].SetAngularVelocity(0);
			bodies[num_players-1].CreateFixture(myFixture);
			bodies[num_players-1]["playerID"] = data.other_playerID;
			console.log("num_players: " + num_players);		
			console.log("player ID: " + bodies[num_players-1]["playerID"]);
		
		}
	
	
	});
	function positionAndAngle(positionX, positionY, angle) {
		this.positionX = positionX;
		this.positionY = positionY;
		this.angle = angle;	
	}
	
	//var posAngArray = new Array();
	socket.on('pos data', function(data) {
		//console.log(data.playerID);
		//posAngArray[data.playerID] = new positionAndAngle(data.positionX, data.positionY, data.angle);
		console.log("receiving position data for ID: " + data.playerID);
		bodies[data.playerID].SetPositionAndAngle(new b2Vec2(data.positionX, data.positionY), data.angle);
		//console.log("player ID " + p_id + " detects movement of " + data.playerID);
		/*
		for(i = 0; i < posAngArray.length; i++) {
			posX = posAngArray[i].positionX;
			posY = posAngArray[i].positionY;
			ang = posAngArray[i].angle;
			bodies[i].SetPositionAndAngle(new b2Vec2(posX,posY), ang);					
		}
		*/
		world.Step(1/60, 10, 10);
		world.DrawDebugData();			
	
		world.ClearForces();
	});
	
	
	
	var mouseX, mouseY, mousePVec, isMouseDown;
	var canvasPosition = getElementPosition(document.getElementById("canvas")); 
	document.addEventListener("mousedown", function(e) {
		isMouseDown = true;
		handleMouseMove(e);
		document.addEventListener("mousemove", handleMouseMove, true);
		started = true;
	}, true);
	
	document.addEventListener("mouseup", function() {
		document.removeEventListener("mousemove", handleMouseMove, true);
		isMouseDown = false;
		mouseX = undefined;
		mouseY = undefined;
	}, true);
	
	function handleMouseMove(e) {
		mouseX = (e.clientX - canvasPosition.x) / 10;
		mouseY = (e.clientY - canvasPosition.y) / 10;
		//console.log(mouseX + " " + mouseY);
		
	};
	function getElementPosition(element) {
		var elem=element, tagname="", x=0, y=0;
		while((typeof(elem) == "object") && (typeof(elem.tagName) != "undefined")) {
			y += elem.offsetTop;
			x += elem.offsetLeft;
			tagname = elem.tagName.toUpperCase();
			if(tagname == "BODY")
				elem=0;
			if(typeof(elem) == "object") {
				if(typeof(elem.offsetParent) == "object") {
					elem = elem.offsetParent;
				}
			}
		}
		return {x: x, y: y};
	}
	var debugDraw = new b2DebugDraw();
	debugDraw.SetSprite(document.getElementById ("canvas").getContext("2d"));
	debugDraw.SetDrawScale(10);
	debugDraw.SetFillAlpha(0.5); //define transparency
	debugDraw.SetLineThickness(1.0); //defines thickness of lines or boundaries
	debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
	world.SetDebugDraw(debugDraw);
	
	//window.setInterval(update, 1000/60);
	window.setInterval(function() {
		if(started == true) {
			socket.emit('mouse data', {playerID: p_id, isMouseDown: isMouseDown, mouseX: mouseX, mouseY: mouseY })
		}			
	}, 1000/60);
	

	/*
	function update() {
		//console.log("bodies.length: " + bodies.length);
		for(i = 0; i < posAngArray.length; i++) {
			posX = posAngArray[i].positionX;
			posY = posAngArray[i].positionY;
			ang = posAngArray[i].angle;
			bodies[i].SetPositionAndAngle(new b2Vec2(posX,posY), ang);					
		}
		
		world.Step(1/60, 10, 10);
		world.DrawDebugData();			
	
		world.ClearForces();
		
	}	
	*/
	
</script>








</html>